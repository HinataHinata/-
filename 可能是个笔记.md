#    还是写一个笔记吧
## ====我就是我 是颜色不一样的烟火 ====

# [2017-07-04 协程 python]

> 英文名Coroutine

> 协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比线程数量越多，协程的性能优势就越明显。

> 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

> 协程是用 generator 实现的 也就是 python 中的 yield 关键字

> 实际上也是处理了调用与线程的关系。按照文档中的说法，是提出了新的 线程与调用的模型。函数调用可以认为是一种特殊的协程。协程本质上使用的是线程内部的中断技术。

# [2017-07-05 复习一下 python 教程 把没记住的知识点总结一哈]

> 01 print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出。遇到','的地方会输出空格
>>    例如 print('1','2','3') 将输出 1 2 3

> 02 通过 input() 函数获取输入 
    例如 name = input() 或者带参数 name = input('please input your name:')

> 03 字符串表示 r'' 前缀表示字符串不转义
    例如 字符串中的内容是 \r\n 如果用转义则表示为 \\r\\n 或者表示为 r'\r\n'
    ‘’‘ 可以输入多行内容 并且用 ''' 结束
    '''前可以加上 r 前缀 表示不对多行内容进行转义 内容里可以有 \r\n 等内容

> 04 b 前缀表示 字符串的 bytes 数据
    例如 'ABC'.encode('ascii') = b'ABC' '中文'.encode('utf-8') = b'\xe4\xb8\xad\xe6\x96\x87'
    可以用 len() 函数 获取字符串或者 bytes 的长度

> 05 格式化字符串
    %d 表示整数 %f 表示浮点数 %s 表示字符串 %x表示十六进制整数
    整数和浮点数可以在前边补数字和0决定整数与小小数的位数　
    '%2d-%02d' % (3,1)
    '%.2f' % 3.1415926
    '%010.2f'  % 3.1415926
    %s 会将任何数据类型转换为字符串
    使用 %% 表示一个字符串 %

> 06 list 支持的一些方法
    len() 获取元素个数
    list[0] 获取 index 个元素
    list[-1] 获取倒数第 index 个元素
    list.append(element) 向末尾添加元素
    list.insert(1,element) 插入元素
    list.pop() 删除并返回最后一个元素
    list.pop(1) 删除并返回第 index 个元素
    list[1] = element 修改元素
    list 中的元素可以使不同类型
    list 中可以包含一个 list

> 07 tuple 的一些问题
    tuple 是不可变的 list 必须在初始化的时候设定好元素内容
    定义只有一个元素的tuple t = (1,) 因为写成 t = (1) 的时候，会被认为是 t = 1 被认为是一个变量
    在 print 显示的时候也会显示为 t = (1,)

08 int(s) 把字符串转换为 int 类型

09 range(t) 表示生成从 0 开始到小于 t 的整数
    可以使用 list() 函数转换为 list 例如 list(range(1,5)) = [1,2,3,4]
    range(t) 实际上是生成了 range(0,t) 对象 for in 可以作用于 range() 对象 遍历所有元素

10 dict 支持的相关操作
    x in dict 可以判断字典中是否存在某个元素，避免获取不存在的 key 报错
    或者可以使用 dict 的获取方法 dict.get(key) dict.get(key,defaultValue) 来获取
    可以使用 dict.pop(key) 从字典中删除元素
    dict 的 key 必须是不可变的对象

11 set 相关的操作 set 不包含重复的元素
    使用 list 初始化 set  s = set([1,2,3])
    set.add(key) 向 set 中添加元素
    set.remove(key) 删除元素 set 删除元素的操作是 remove() 而不是 pop()

12 max() 函数可以接受任意多个参数 返回最大的元素,也可以接收 list 参数 返回 list 中最大的元素

13 关于函数 函数可以返回多个值 也可以用多个变量接收函数的返回值。 例如 x,y = destination(originalX,originalY,move)
    实际上 是通过 tuple 操作的。语法省略了这一过程。
    函数可以有默认参数 即在函数头中设置默认值，例如 circle(x = 0,y = 0)
    但是函数的默认参数需要指向不可变对象 因为 python 的实现中有一些细节问题，貌似不会干掉调用过程中的过程参数
    举一个例子 def append_end(L = []):L.append('END') 这个方法在多次调用 append_end() 后会添加多个 END 因为过程参数没被干掉
    所以需要修改为 
    def append_end(L=None):
        if L == None:
            L = []   
        L.append('END')
        return L

14 函数的可变参数
    可以通过参数名前加 * 的方式，传入可变参数 例如 def sum(*numbers): sum = 0 for x in numbers: sum = sum + x return sum
    可以在 list 或者 tuple之前添加 * 的方式 将 list 和 tuple 转换为可变参数 例如 L = [1,2,3] sum(*L)

15 可变参数允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict.
    不过这种方式传入的 dict 不会对字段 key 做限制
    可以通过 命名关键字参数限制关键字 例如 def person(name,age,*,city,job): 或添加默认值 def person(name,age,*,city='BeiJing',job):

[2017-07-06 继续复习 python]
01 函数的尾递归优化 在函数的 return 语句调用自身 python 没有做尾递归优化
    递归调用 HannoiTwer
def HannoiTower(n,A,B,C):
    if n == 1:
        print(A,'->',C)
    else:
        move(n-1,A,C,B)
        print(A,'->',C)
    move(n-1,B,A,C)

move(3,'A','B','C')
02 python 提供了下标的切片操作 list tuple string 都可以使用切片
    切片的大致规则是 list[from:to:step] 同时，参数支持负数 -1 表示倒数第一个
03 可以用于 for-in 的对象称为 Iterable 可以用 isinstance(object,Iterable) 判断是否可以用于 for-in 语句
04 可以用 enumerate() 方法获取 list 的索引 例如 for i,value in enumerate([1,2,3])
05 列表生成式
    [x * x for x in range(10)] 一般形式
    [x * x for x in range(10) if x %2 == 1] 添加条件形式
    [m + n for m in 'ABC' for n in 'abc']
    import os
    [d for d in os.listdir('.')] 列出当前目录
    d = {'1':'A','2':'B'}
    [k + '=' + v for k,v in d.items()] dict.items() 获取字典元素的 key-value 对
06 生成器 generator python 中一种一边循环一遍计算的机制 
    g = (x * x for x in range(10)) 即可创建一个列表生成器
    next() 方法可以获取 generator 的下一个元素值 超出范围后 抛出 StopIteration 错误
    可以用 for-in 语句依次获取 generator 中的对象 遍历结束之后循环终止。
    可以用 yield 关键字创建生成器 生成器在 yield 关键字处返回，下次执行的时候从 yield 关键字继续执行。
07 可以用于 for-in 操作的对象称为可迭代对象。 如 list tuple dict set str 和 generator
    可以用 isinstance(object,Iterable) 判断是不是一个可迭代对象
    迭代器 不仅可以用于 for-in 操作，还可以使用 next(object) 获取下一个对象。
    可以用 iter() 将list dict str 转换为迭代器。转换之后得到的结果是 generator 的子类
    可以看到：
    iter(list) = list_iterator isinstance(iter(list),generator) = True
    iter()iter = str_iterator isinstance(iter('abc'),generator) = True

08 高阶函数 函数可以用函数作为参数 称为高阶函数 例如：
    def add(x,y,f):
        return f(x)+f(y)

09 map/reduce 在 python 中使用 reduce 需要 from functools import reduce
    map 的一般形式 map(f,L) f 函数依次作用于 L 中的元素 然后生成新的 generator 可以用 list() 函数转换为一个 list
    reduce 的一般形式 reduce(f,L) f 函数接受两个参数 返回一个结果 依次作用于 L 中的所有元素 类似于 小鱼吃豆豆
10 有一个操作需要习惯一下 就是在函数内部定义函数。这种写法个人感觉不适很好，但是有的时候还是比较有用的。
    def prod(L):
        def mul(x,y):
            return x*y
        reduce(mul,L)

    pord([1,2,3,4,5])
11 filter() 方法 接收一个函数 f 和一个list f 依次作用于 list 中的每个元素，然后生成一个 generator 
    通过写一个例子可以看出 filter 中的 f 函数是在获取 generator 中的元素的时候，采真正执行的
    def zcfilter(num):
        print('calling zcfilter...')
        return num % 2 == 0
    L = filter(zcfilter,[1,2,3,4,5,6,7,8,9])
    list(L)
12 sorted 函数可以用于排序 基本使用方法 sorter(L,key= abs,reverse=True) 其中 key 参数将作用于 L 中的元素，然后参与排序 并且 不会改变 L 的值
13 字符串方法的调用一般可以使用两种形式 'ABC'.lower() 'ABC'.capitalize() 和 str.lower('ABC') str.capitalize('ABC')




