#    还是写一个笔记吧
## ====我就是我 是颜色不一样的烟火 ====

# [2017-07-04 协程 python]

01. 英文名Coroutine
02. 协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比线程数量越多，协程的性能优势就越明显。
03. 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。
04. 协程是用 generator 实现的 也就是 python 中的 yield 关键字
05. 实际上也是处理了调用与线程的关系。按照文档中的说法，是提出了新的 线程与调用的模型。函数调用可以认为是一种特殊的协程。协程本质上使用的是线程内部的中断技术。

# [2017-07-05 复习一下 python 教程 把没记住的知识点总结一哈]

01. print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出。遇到','的地方会输出空格
* 例如 print('1','2','3') 将输出 1 2 3

02. 通过 input() 函数获取输入 
* 例如 name = input() 或者带参数 name = input('please input your name:')

03. 字符串表示 r'' 前缀表示字符串不转义
* 例如 字符串中的内容是 \r\n 如果用转义则表示为 \\r\\n 或者表示为 r'\r\n'
* ‘’‘ 可以输入多行内容 并且用 ''' 结束
* '''前可以加上 r 前缀 表示不对多行内容进行转义 内容里可以有 \r\n 等内容

04. b 前缀表示 字符串的 bytes 数据
*例如 'ABC'.encode('ascii') = b'ABC' '中文'.encode('utf-8') = b'\xe4\xb8\xad\xe6\x96\x87'
*可以用 len() 函数 获取字符串或者 bytes 的长度

05. 格式化字符串
* %d 表示整数 %f 表示浮点数 %s 表示字符串 %x表示十六进制整数
* 整数和浮点数可以在前边补数字和0决定整数与小小数的位数
* '%2d-%02d' % (3,1)
* '%.2f' % 3.1415926
* '%010.2f'  % 3.1415926
* %s 会将任何数据类型转换为字符串
* 使用 %% 表示一个字符串 %

06. list 支持的一些方法

```py
len() # 获取元素个数
list[0] # 获取 index 个元素
list[-1] # 获取倒数第 index 个元素
list.append(element) # 向末尾添加元素
list.insert(1,element) # 插入元素
list.pop() # 删除并返回最后一个元素
list.pop(1) # 删除并返回第 index 个元素
list[1] = element # 修改元素
```
* list 中的元素可以使不同类型
* list 中可以包含一个 list


07. tuple 的一些问题
* tuple 是不可变的 list 必须在初始化的时候设定好元素内容
* 定义只有一个元素的tuple t = (1,) 因为写成 t = (1) 的时候，会被认为是 t = 1 被认为是一个变量
* 在 print 显示的时候也会显示为 t = (1,)

08. int(s) 把字符串转换为 int 类型

09. range(t) 表示生成从 0 开始到小于 t 的整数
* 可以使用 list() 函数转换为 list 例如 list(range(1,5)) = [1,2,3,4]
* range(t) 实际上是生成了 range(0,t) 对象 for in 可以作用于 range() 对象 遍历所有元素

10. dict 支持的相关操作
* x in dict 可以判断字典中是否存在某个元素，避免获取不存在的 key 报错
* 或者可以使用 dict 的获取方法 dict.get(key) dict.get(key,defaultValue) 来获取
* 可以使用 dict.pop(key) 从字典中删除元素
* dict 的 key 必须是不可变的对象

11. set 相关的操作 set 不包含重复的元素
* 使用 list 初始化 set  s = set([1,2,3])
* set.add(key) 向 set 中添加元素
* set.remove(key) 删除元素 set 删除元素的操作是 remove() 而不是 pop()

12. max() 函数可以接受任意多个参数 返回最大的元素,也可以接收 list 参数 返回 list 中最大的元素

13. 关于函数
* 函数可以返回多个值 也可以用多个变量接收函数的返回值。 例如 x,y = destination(originalX,originalY,move)
* 实际上 是通过 tuple 操作的。语法省略了这一过程。
* 函数可以有默认参数 即在函数头中设置默认值，例如 circle(x = 0,y = 0)
* 但是函数的默认参数需要指向不可变对象 因为 python 的实现中有一些细节问题，貌似不会干掉调用过程中的过程参数
* 举一个例子 def append_end(L = []):L.append('END') 这个方法在多次调用 append_end() 后会添加多个 END 因为过程参数没被干掉
* 所以需要修改为 
```py
def append_end(L=None):
    if L == None:
        L = []   
    L.append('END')
    return L
```

14. 函数的可变参数
* 可以通过参数名前加 * 的方式，传入可变参数 例如 def sum(*numbers): sum = 0 for x in numbers: sum = sum + x return sum
* 可以在 list 或者 tuple之前添加 * 的方式 将 list 和 tuple 转换为可变参数 例如 L = [1,2,3] sum(*L)

15. 可变参数
* 可变参数允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict.
* 不过这种方式传入的 dict 不会对字段 key 做限制
* 可以通过 命名关键字参数限制关键字 例如 def person(name,age,*,city,job): 或添加默认值 def person(name,age,*,city='BeiJing',job):

# [2017-07-06 继续复习 python]

01. 函数的尾递归优化 在函数的 return 语句调用自身 python 没有做尾递归优化
* 递归调用 HannoiTwer
```py
def HannoiTower(n,A,B,C):
    if n == 1:
        print(A,'->',C)
    else:
        move(n-1,A,C,B)
        print(A,'->',C)
    move(n-1,B,A,C)
move(3,'A','B','C')
```
02. python 提供了下标的切片操作 list tuple string 都可以使用切片
* 切片的大致规则是 list[from:to:step] 同时，参数支持负数 -1 表示倒数第一个
03. 可以用于 for-in 的对象称为 Iterable 可以用 isinstance(object,Iterable) 判断是否可以用于 for-in 语句
04. 可以用 enumerate() 方法获取 list 的索引 例如 for i,value in enumerate([1,2,3])
05. 列表生成式
```py
[x * x for x in range(10)] # 一般形式
[x * x for x in range(10) if x %2 == 1] # 添加条件形式
[m + n for m in 'ABC' for n in 'abc']
import os
[d for d in os.listdir('.')] # 列出当前目录
d = {'1':'A','2':'B'}
[k + '=' + v for k,v in d.items()] dict.items() # 获取字典元素的 key-value 对
```

06. 生成器 generator python 中一种一边循环一遍计算的机制    
* g = (x * x for x in range(10)) 即可创建一个列表生成器
* next() 方法可以获取 generator 的下一个元素值 超出范围后 抛出 StopIteration 错误
* 可以用 for-in 语句依次获取 generator 中的对象 遍历结束之后循环终止。
* 可以用 yield 关键字创建生成器 生成器在 yield 关键字处返回，下次执行的时候从 yield 关键字继续执行。

07. 可以用于 for-in 操作的对象称为可迭代对象。 如 list tuple dict set str 和 generator
* 可以用 isinstance(object,Iterable) 判断是不是一个可迭代对象
* 迭代器 不仅可以用于 for-in 操作，还可以使用 next(object) 获取下一个对象。
* 可以用 iter() 将list dict str 转换为迭代器。转换之后得到的结果是 generator 的子类
* 可以看到：
```py
    iter(list) = list_iterator isinstance(iter(list),generator) = True
    iter()iter = str_iterator isinstance(iter('abc'),generator) = True
```

08. 高阶函数 函数可以用函数作为参数 称为高阶函数 例如：
```py
def add(x,y,f):
    return f(x)+f(y)
```

09. map/reduce
* 在 python 中使用 reduce 需要 from functools import reduce
* map 的一般形式 map(f,L) f 函数依次作用于 L 中的元素 然后生成新的 generator 可以用 list() 函数转换为一个 list
* reduce 的一般形式 reduce(f,L) f 函数接受两个参数 返回一个结果 依次作用于 L 中的所有元素 类似于 小鱼吃豆豆

10. 有一个操作需要习惯一下 - 在函数内部定义函数。
* 这种写法个人感觉不适很好，但是有的时候还是比较有用的。
```py
def prod(L):
    def mul(x,y):
        return x*y
    reduce(mul,L)
pord([1,2,3,4,5])
```

11. filter() 方法 接收一个函数 f 和一个list f 依次作用于 list 中的每个元素，然后生成一个 generator 
* 通过写一个例子可以看出 filter 中的 f 函数是在获取 generator 中的元素的时候，采真正执行的
```py
def zcfilter(num):
    print('calling zcfilter...')
    return num % 2 == 0
L = filter(zcfilter,[1,2,3,4,5,6,7,8,9])
list(L)
```

12. sorted 函数可以用于排序 基本使用方法 sorter(L,key= abs,reverse=True) 其中 key 参数将作用于 L 中的元素，然后参与排序 并且 不会改变 L 的值
13. 字符串方法的调用一般可以使用两种形式 'ABC'.lower() 'ABC'.capitalize() 和 str.lower('ABC') str.capitalize('ABC')

# [2017-07-07 继续复习 python]

01. 高阶函数可以返回函数。 返回的函数在返回结果执行的时候真正的执行。
```py
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in ax:
            ax = ax + n
        return ax
    return sum

f = lazy_sum(1,2,3,4,5) # 此时，sum() 函数并没有真正的执行
result = f() # 这个时候，才真正的执行 sum()
print(result)

# 调用 lazy_sum() 时，每次都会返回一个新的函数，即使参数时一样的
f1 = lazy_sum(1,2,3)
f2 = lazy_sum(1,2,3)
f1 == f2 (False)
```
02. 闭包的概念 把相关参数和变量都保存在返回的函数中
* 返回函数不可以引用任何循环变量，除非是可以这样做的。因为返回的函数是在真正调用的时候才执行的，所以依赖循环变量的函数会发生参数错误。

03. 匿名函数 就是传说中的 lambda 表达式
* 匿名函数 只能有一个表达式，不用写 return 返回值就是表达式的结果。
```py
# lambda 表达式表示为函数形式
lambda x: x * x
def f(x):
    return x * x
```
* 匿名函数可以赋值给变量，也可以作为函数的返回值返回。
* python 对匿名函数的支持有限。

04. 装饰器 装饰器的原理是 修改原函数指向的对象，指向一个返回原函数的函数，并在这个函数中做一些额外的操作。
* 函数可以赋值给变量，通过 () 操作符执行。 函数有一个 __name__的属性，可以拿到函数的名字。
```py
def doSomething():
    print('dosomething')
f = doSomethign
f()
# 获取函数名称
doSomething.__name__
f.__name
```
* 定义一个打印调用函数名字的 log 函数
```py
def log(func):
    def wrapper(*args,**kw):
        print('call %s():' % func.__name__)
        return func(*args,**kw)
    return wrapper

@log 
def bark():
    print('barking...')

bark()
```
* 把 @log 放到函数 bark 的定义处 相当于执行了语句 bark = log(bark) 即 改变了函数的定义，用包装过后的函数替代之前的函数。
* 下边这个例子可以看的更清楚
```py
def lightOn():
    print('turn light on...')

f = log(lightOn)
f # <function log.<locals>.wrapper>
f() # call lightOn() turn light on
lightOn.__name__ # wrapper
```
* 实际上就是通过返回函数，玩了一个修改函数指针的小把戏
* 如果需要定义打印的文字的话，为了传入参数，需要多定义一层函数 即最外层函数返回 装饰器
```py
def log(text):
    def decorator(func):
        def wrapper(*args,**kw):
            print('%s %s():' % (text,func.__name__))
        return wrapper
    return decorator
```
* 三层嵌套的调用套路是 log('description')(func)() 执行
* 由于使用 wrapper 之后，func.__name__ 是 wrapper 依赖 __name__ 的代码就会出问题，所以 python functools.wraps 专门处理了这个问题 import functools 之后 在 wrapper() 上加上 @functools.wraps(func) 即可修正函数名
```py
import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args,**kw):
        print('calling %s()' % func.__name__)
        return func(*args,**kw)
    return wrapper

@log
def bark():
    print('dog bark')

bark() # balling bark() dog bark
bark.__name__ # 'bark'
```

05. 偏函数 python 支持从一个函数添加默认参数直接创建另外一个函数 需要 import functools
```py
import functools
int2 = functools.partial(int,base=2)
int2('1000000') # 64
int2('1010101') # 85
#类似于编写了一个函数
def int2(x):
    return int(x,base=2)
```
* functools.partial(func,argument) 会将参数添加到 func 的参数列表中
```py
#import functools
int2 = functools.partial(int,base=2) # 相当于 kw = {'base':2} int('10010',**kw)
max2 = functools.partial(max,10) # 会将 10 添加到参数列表中
max2(1,2,7) # 相当于 max(10,1,2,7)
```
06. 模块 为了维护代码，把相关脸的代码放到一个组里，称为模块。python 中一个 .py 文件就是一个模块
* 可以把多个 python 文件放入一个包中 例如 web.abc web.xyz 每一个包目录下都会有一个 __init__.py 文件，这个文件可以是空文件也可以有代码。如果没有这个文件， python 就会把目录当成一个普通目录，而不是当成一个包。
* 包可以有上下级的层级结构 但是每一层都要有一个 __init__.py 文件

07. 使用模块 import + 包名 后可以使用包中的组件。
* import sys 可以使用 sys 模块。 sys.argv 可以获取参数

08. 作用域
* 正常函数和变量名是公开的 (public) 
* 类似 __xxx__ 这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如 __author__访问作者名,__name__访问文件名,__doc__ 访问文档注释。 自己一般不要定义这种变量名。
* 类似 _xxx 和 __xxx 这样的函数或变量就是非公开的，(private)，不应该直接被引用。

09. 安装第三方模块
* 通过包管理工具 pip 完成。
* 安装第三方库 pip3 install xxx 使用第三方库 import xxx 或者 from xxx import yyy
* import sys sys.path 可以打印 python 的环境变量

10. 面向对象编程
* python 定义累对象的方式比较随意，随手一写就是一个属性。
```py
class Student(object):
    def __init__(self,name,score):
        self.name = name
        self.score = score
    def print_score(self):
        print('%s %s' % (self.name,self.score)
```
11. 类和实例
* 属性的赋值也很随意，就算没有这个属性，也可以给这个属性赋值，会添加一个叫这个名字的属性。 别人知不知道就看他自己本事了。
* 实例变量必须包含的属性需要在 __init__(self) 方法中定义。

12. 访问限制
* 属性名前加上 __ 可以不被外部访问。例如在 　__init__ 中写到 self.__name = name 就不能直接访问 __name 了
* 如果需要访问权限 可以使用 set／get 方法提供访问方式。
* 实际上 __name 属性是被改了名字，可以通过 self._classname__name访问。但是最好不要这个样子。

13. 获取对象信息
* 可以通过 type() 函数获取一个对象的类型信息。例如 type('123') type(123) type(abs)
* types 模块包含了关于类型的信息 import 之后可以使用 例如 types.FunctionType types.BuildinFunctionType types.lambdaType
* 可以使用 isinstance 判断是不是某个类型及其子类。 还可判断是不是某些类型中的一种
```py
 isinstance([1,2,3],(list,tuple))
```
* 可以使用 dir() 方法获取一个对象的所有属性和方法。
```py
dir('abc')
```
* len(object) 实际上是调用了 object.__len__() 如果想要自己的类型支持 len(yourObject) 需要在自己的类中 实现 __len__()方法。
* hasattr(obj,'x') setattr(obj,'x') getattr(obj,'x') getattr(obj,'x',defaultValue) 功能分别如方法名所说。
* read() 方法是流式对象的方法，可以是文件流，可以是网络流，总之是流，有点像接口的概念。

14. 实例属性和类属性 
* 当实例对象属性不存在时，将返回类的同名属性的值。类属性可以用类访问也可以用实例访问。 尽量不要使用相同名称的类属性和实例属性。
* 使用 del s.name 删除实例对象的属性。 就算是 __init__ 文件中定义的属性也可以删除。真是醉醉的。
15. 面向对象高级编程
* 给实例变量绑定方法。 需要 from types import MethodType
```
class Student(object):
    pass

def set_age(self,age):
    self.age = age

from types import MethodType
s.set_age = MethodType(set_age,s)
```
* 给实例绑定方法不会影响其他实例对象。 如果要对所有实例起作用，需要给类添加方法。
```py
class Student(object):
    pass
def set_score(self,score):
    self.score = score
Student.set_score = set_score
```
* 如果不想对象动态添加乱七八糟的属性，可以使用 __slots__ 关键字加以限制
```py
class Student(object):
    __slot__ = ('name','score')
```
* 使用 __slot__ 关键字只对当前类起作用 不会影响子类。如果在子类中也添加了 __slots__ 关键字 那么属性就是子类 __slots__ 加上父类 __slots__

# [2017-07-08 继续复习 python]
01. 属性 python 中属性用装饰器实现。如果不定义 setter 就是只读属性。
```py
# 感觉 python 定义属性的方式好蠢。
class Student(object):
    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self,value):
        self._birth = value

    @property
    def age(self)
        return 2017 - self._birth
```
02. 多重继承 多重继承在继承的父类中用 , 隔开就好。表示一个概念上的多重继承。
```py
class Dog(Animal,Runnable):
    pass
```
03. 定制类 类似于 __xxx__ 这样的变量在 python 中是有特殊用途的。
* __str__ 变量可以定制对象在打印的时候的内容
```py
class Student(object):
    def __init__(self,name):
        self.name = name

    def __str__(self):
        return 'Student object (name:%s)' % self.name

print(Student('XiaoMing'))
```
* __iter__ 如果想要被用于 for-in 操作，需要实现一个 __iter__() 方法，该方法返回一个迭代对象，for 循环会调用该对象的 __next__() 方法获取下一个值。
```py
class Fib(object):
    def __init__(self):
        self.a = 1
        self.b = 1
    def __iter__(self):
        return self
    def __next__(self):
        if self.b < 10000:
            self.a,self.b = self.b,self.a+b
            return self.a
        else:
            raise StopIteration()

for n in Fib():
    print(n)
```
* __getitem__ 使对象支持按索引取元素。
```py
class Fib(object):
    def __getitem__(self,n)
        a,b = 0,1
        for x in range(n):
            a,b = b,a+b
        return a
Fib(0)
Fib(1)
Fib(2)
```
* 但是 list 支持切片操作，如果要支持切片操作，__getitem__ 还需要做一些额外的工作。
```py
class Fib(object):
    def __getitem__(self,n):
        if isinstance(n,int):
            a,b = 0,1
            for x in range(n):
                a,b = b,a+b
            return a
        if isinstance(n,slice): # 如果是切片的话
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a,b = 1,1
            L = []
            for x in range(stop):
                if x >= start:
                    L.append(a)
                a,b = b,a+b
            return L
```
* __getattr__ 如果调用未定义的属性的话，会通过 __getattr__ 尝试获取结果。
```py
class Student(object):
    def __init__(self):
        self.name = 'XiaoMing'
    def __getattr__(self,attr):
        if attr == 'score':
            return 99
        if attr == 'age':
            return lambda:25 # 也可以返回函数 student.age() 调用
```
* 需要注意，__getattr__ 默认返回None (什么鬼，这不是搞笑吗。。) 如果要 class 只响应几个特定的属性，需要跑出 AttributeError 错误。
```py
class Student(object):
    def __getattr__(self,attr):
        if attr == 'age':
            return lambda:25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
```
* __call__ 定义之后可以在对象上 执行 ()
```py
class Student(object):
    def __init__(self,name='XiaoMing'):
        self.name = name
    def __call__(self):
        print('My name is %s' % self.name)
stu = Student('XiaoFang')
stu()
# 可以使用 callable() 判断是否支持 () 操作
callable(stu) # True
callable('abc') # False
```
04. 使用枚举量
```py
from enum import Enum
Month = Enum('Month',('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

for name,member in Month.__members__.items():
    print(name,'=>',member.value)
* 如果要定义变量值，需要定义 Enum 的子类
```py
from enum import Enum
@unique
class Weekday(Enum):
    Sun = 0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
# 支持多种访问方式
Weekday.Mon
Weekday(1)
```
05 使用元类 metaclass 用于创建类
* type 可以获取对象的类型，也可以用于创建类型。
```py
class Hello(object):
    def hello(self):
        print('Hello World')

h = Hello()
type(Hello) # <class 'type'>
type(h) # <class '__main__.Hello'>
type(h.hello) # <class 'method'>

# 创建类对象
def fn(self):
    print('Hello World')

Hello = type('Hello',(object,),dict(hello=fn)) # 创建 Hello class
h = Hello()
h.hello()
print(type(Hello)) # <class 'type'>
print(type(h)) # <class '__main__.Hello'>
```
* metaclass 用于限制创建类的行为。默认习惯className+Metaclass 命名 例如 ListMetaclass
```py
# metaclass 是类的模版 从type派生
class ListMetaclass(type):
    def __new__(cls,name,bases,attrs):
        attrs['add'] = lambda self,value:self.append(value)
        return type.__new__(cls,name,bases,attrs)
class MyList(list,metaclass=ListMetaclass):
    pass
```
* 当定义了 metaclass 参数，python 的解释器在创建 MyList 时要通过 ListMetaclass.__new__() 来创建
* __new__() 方法接收到的参数依次是 当前准备创建的类的对象，类的名字 类继承的父类的集合 类的方法集合。
```py
L = MyList()
L.add(1)
print(L)
```
* 这种操作一般用在需要动态添加方法的情况下。例如做一个 ORM。所有的方法需要动态添加。

# [2017-07-09 继续复习 python]
01. python 中使用 try except finally 进行异常捕获。
```py
try:
    print('try...')
    r = 10/0
    print('result:',r)
except ZeroDivisionError as e:
    print('except:',e)
finally:
    print('finally...')
print('END')
```
02. python 的错误也是类，错误类型的基类是 BaseException 异常会捕获子类型错误。
03. logging 模块可以打印错误信息。 在异常捕获部分 调用 logging.exception(e) 需要 import logging
04. raise 语句用于抛出异常，可以自定义错误类型然后抛出异常。
```py
class FooError(ValueError):
    pass

def foo(s):
    n = int(s)
    if n == 0:
        raise FooError('invalid value:%s' % s)
    return 10/n

foo('0')
```
05. raise 语句如果不带参数，将把原有异常继续向上层抛出。
```py
def bar():
    try:
        foo('0')
    except ValueError as e:
        # 记录错误 并继续抛出。
        print('ValueError')
        raise

bar()
```
# [2017-07-09 继续复习 python]
01. 在家里的 Windows 台式机安装了 python 和 tensorflow
* 喝了剩下宝贝的冰粥，还可以。
# [2017-07-10 继续复习 python]
01. 今天准备一下考试。
# [2017-07-11 继续复习 python]
01. 使用 Metaclass 示例 ORM
```py
class Field(object):
    def __init__(self,name,column_type):
        self.name = name
        self.column_type = column_type

    def __str__(self):
        return  '<%s:%s>' % (self.__class__.__name__,self.name)

# 子类化 Field
class StringField(Field):
    def __init__(self,name):
        super(StringField,self).__init__(name,'varchar(100)')

class IntegerField(Field):
    def __init__(self,name):
        super(IntegerField,self).__init__(name,'bigint')

# Model MetaClass
class ModelMetaclass(type):
    def __new__(cls,name,bases,attrs):
        print('ModelMetaclass name:%s' % name)
        if name == 'Model':
            return type.__new__(cls,name,bases,attrs)
        print('Found Model: %s' % name)
        mappings = dict()
        for k,v in attrs.items():
            if isinstance(v,Field):
                print('Found mapping:%s ==> %s' % (k,v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs['__mappings__'] = mappings; # 保存属性列表映射关系
        attrs['__table__'] = name # 假设表名和类名一致
        return  type.__new__(cls,name,bases,attrs)

class Model(dict,metaclass= ModelMetaclass):
# Model 类接收一个字典参数。
    def __init__(self,**kw):
        super(Model,self).__init__(**kw)
    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Model' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        args = []

        for k,v in self.__mappings__.items():
            fields.append(v.name)
            params.append('?')
            args.append(getattr(self,k,None))
        sql = 'insert into %s (%s) values (%s)' % (self.__table__,','.join(fields),','.join(params))
        print('SQL:%s' % sql)
        print('ARGS:%s' % str(args))

class User(Model):
# 定义类的属性到数据库字段到映射
    id = IntegerField('id')
    name = StringField('username')
    email = StringField('email')
    password = StringField('password')

u = User(id = 12345,name = 'XiaoMing',email = 'xiaoming@163.com',password = '123456')
# 保存到数据库
u.save()
```
02. 断言 断言可以替代 print 在调试的时候输出日志
```py
def foo(s):
    n = int(s)
    assert n != 0,'n is zero!' # 当 assert 语句为 false 时，会抛出 AssertionError 并输出日志。
    return 10/n
def main():
    foo('0')
```
* 在启动 python 解释器的时候，可以通过 -o 参数关闭 assert。关闭之后，可以把 assert 当作 pass。
03. logging 也可以记录日志 并且可以输出到文件。
```py
import logging
logging.basicConfig(level=logging.INFO)
s = '0'
n = int(s)
logging.info('n=%d' % n)
print(10/n)
```
* logging 可以指定记录信息的级别。从上倒下依次为 debug/info/warning/error 当指定 level 为 info 时，debug 信息就不会输出了。
```py
logging.basicConfig(filename='logger.log',level = logging.INFO)
```
04. pdb 使用命令行启动 pdb 模式调试 python (太费劲了 忽略) & 使用 IDE 调试 python
05. 单元测试 需要引入 python 自带的单元测试模块 import unittest
* 以 test 开头的方法就是测试方法，不以 test 开头的方法测试的时候不执行
* unittest.TestCase 提供很多内置的条件判断 如self.assertEqual() self.assertTrue()
* with 语句可以测试是否抛出制定类型的异常。
* 运行测试单元 
+ 一种是在测试文件末尾加上 if __name__ == '__main__': unittest.main()
+ 另外一种是在命令行中通过参数 -m unittest 直接运行单元测试 例如 python3 -m unittest mydict_test
* setUp 和 tearDown 这两个方法分别在每一个测试方法调用之前和之后执行。
* 测试代码不可以过于复杂 过于复杂的测试代码可能本身就有 bug
* 示例测试一个 dict 类
```py
# mydict.py
class myDict(dict):
    def __init__(self,**kw):
        super().__init(**kw)
    def __getattr__(self,key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Dict' object has no attribute '%s'" % key)
    def __setattr__(self,key,value):
        self[key] = value
```
```py
#myDict_test.py
import unittest
from mydict import myDict
class TestMyDict(unittest.TestCase):
    def test_init(self):
        d = myDict(a = 1,b = 'test')
        self.assertEqual(d.a,1)
        self.assertEqual(d.b,'test')
        self.assertTrue(isinstance(d,dict))

    def test_key(self):
        d = myDict()
        d['key'] = 'value'
        self.assertEqual(d.key,'value')
    
    def test_attr(self):
        d = myDict()
        d.key = 'value'
        self.assertTrue('key' in d)
        self.assertEqual(d['key'],'value')

    def test_keyerror(self):
        d = myDict()
        with self.assertRaises(KeyError):
            value = d['empty']
    
    def test_attrerror(self):
        d = myDict()
        with self.assertRaises(AttributeError):
            value = d.empty


if __name__ == '__main__':
    unittest.main()
```
06. 文档测试 文档中的测试示例程序。可以被某些工具提取。用到的时候需要仔细看一下。一般编写对外使用的库的时候才会用到。

















